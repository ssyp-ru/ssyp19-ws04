;; Создание глобальных переменных
(defdyn *запросы*)
(defdyn *факты*)
(defdyn *гипотезы*)

(setq *запросы* nil)
(setq *факты* nil)

;; Правила
(setq ПРАВИЛО1 
  '(ЕСЛИ ЖИВОТНОЕ ИМЕЕТ ШЕРСТЬ ТО ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ))
  
(setq ПРАВИЛО2 
  '(ЕСЛИ ЖИВОТНОЕ КОРМИТ ДЕТЕНЫШЕЙ МОЛОКОМ ТО ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ))

(setq ПРАВИЛО3 
  '(ЕСЛИ ЖИВОТНОЕ ИМЕЕТ ПЕРЬЯ ТО ЖИВОТНОЕ ПТИЦА))

(setq ПРАВИЛО4 
  '(ЕСЛИ ЖИВОТНОЕ УМЕЕТ ЛЕТАТЬ И ЖИВОТНОЕ НЕСЕТ ЯЙЦА ТО ЖИВОТНОЕ ПТИЦА))

(setq ПРАВИЛО5 
  '(ЕСЛИ ЖИВОТНОЕ ЕСТ МЯСО ТО ЖИВОТНОЕ ХИЩНИК))

(setq ПРАВИЛО6 
  '(ЕСЛИ ЖИВОТНОЕ ИМЕЕТ ОСТРЫЕ ЗУБЫ И ЖИВОТНОЕ 
    ИМЕЕТ КОГТИ И ГЛАЗА ЖИВОТНОГО ПОСАЖЕНЫ ПРЯМО
    ТО ЖИВОТНОЕ ХИЩНИК))
    
(setq ПРАВИЛО7 
  '(ЕСЛИ ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ И ЖИВОТНОЕ ИМЕЕТ КОПЫТА
    ТО ЖИВОТНОЕ ЖВАЧНОЕ))
    
(setq ПРАВИЛО8 
  '(ЕСЛИ ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ И ЖИВОТНОЕ ЖУЕТ ЖВАЧКУ
    ТО ЖИВОТНОЕ ЖВАЧНОЕ))
    
(setq ПРАВИЛО9 
  '(ЕСЛИ ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ 
    И ЖИВОТНОЕ ХИЩНИК
    И ЖИВОТНОЕ ЖЕЛТО-КОРИЧНЕВОЕ
    И ЖИВОТНОЕ ИМЕЕТ ТЕМНЫЕ ПЯТНА
    ТО ЖИВОТНОЕ ГЕПАРД))
    
(setq ПРАВИЛО10 
  '(ЕСЛИ ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ 
    И ЖИВОТНОЕ ХИЩНИК
    И ЖИВОТНОЕ ЖЕЛТО-КОРИЧНЕВОЕ
    И ЖИВОТНОЕ ПОЛОСАТОЕ
    ТО ЖИВОТНОЕ ТИГР))    

(setq ПРАВИЛО11 
  '(ЕСЛИ ЖИВОТНОЕ МЛЕКОПИТАЮЩЕЕ 
    И ЖИВОТНОЕ ДЛИННОШЕЕЕ
    И ЖИВОТНОЕ ДЛИННОНОГОЕ
    И ЖИВОТНОЕ ИМЕЕТ ТЕМНЫЕ ПЯТНА
    ТО ЖИВОТНОЕ ЖИРАФ))

(setq ПРАВИЛО12 
  '(ЕСЛИ ЖИВОТНОЕ ЖВАЧНОЕ 
    И ЖИВОТНОЕ ПОЛОСАТОЕ
    ТО ЖИВОТНОЕ ЗЕБРА))    

(setq ПРАВИЛО13 
  '(ЕСЛИ ЖИВОТНОЕ ПТИЦА 
    И ЖИВОТНОЕ НЕ УМЕЕТ ЛЕТАТЬ
    И ЖИВОТНОЕ ДЛИННОШЕЕЕ
    И ЖИВОТНОЕ ДЛИННОНОГОЕ
    И ЖИВОТНОЕ ЧЕРНО-БЕЛОЕ
    ТО ЖИВОТНОЕ СТРАУС))

(setq ПРАВИЛО14 
  '(ЕСЛИ ЖИВОТНОЕ ПТИЦА 
    И ЖИВОТНОЕ НЕ УМЕЕТ ЛЕТАТЬ
    И ЖИВОТНОЕ ПЛАВАЕТ
    И ЖИВОТНОЕ ЧЕРНО-БЕЛОЕ
    ТО ЖИВОТНОЕ ПИНГВИН))

(setq *гипотезы* 
  '((ЖИВОТНОЕ ПИНГВИН)
    (ЖИВОТНОЕ СТРАУС)
    (ЖИВОТНОЕ ЗЕБРА)
    (ЖИВОТНОЕ ТИГР)
    (ЖИВОТНОЕ ГЕПАРД)
    (ЖИВОТНОЕ ЖИРАФ)))

(defstruct правило имя условия выводы)

;; Получение "tail"-а от введенного элемента
(defun OwnFooMember (a list)
  (cond ((null list) nil)
        ((equal a (car list)) list)
		(t (OwnFooMember a (cdr list)))))

;; Приоединение атома в конец списка
(defun присоедини (x y)
  (append x (list y)))

;; Создание структуры правил
(defun анализируй-правило (имя)   
   (let ((правило (eval имя)))
      (make-правило :имя имя
                    :условия (условия правило)
                    :выводы (выводы правило))))	

(defun анализируй (правилa)
   (mapcar #'анализируй-правило правилa))

;; Получение условия
(defun условия (предложение)
    (предложение-и (cdr предложение) nil nil))

;; Получение вывода
(defun выводы (предложение)
    (предложение-и 
      (cdr (OwnFooMember 'то предложение)) nil nil))

;; Обработка предложений	  
(defun предложение-и (предложение часть результат)      
    (cond ((null предложение) 
           (присоедини результат часть))
          ((eq (car предложение) 'то)
           (присоедини результат часть))
          ((eq (car предложение) 'и)
           (предложение-и (cdr предложение)
              nil
             (присоедини результат часть)))
          (t (предложение-и (cdr предложение)
             (присоедини часть
                (car предложение))
             результат))))		 

;; Проверка правил
(defun проверь-правило (правило)
  (подмножество (правило-условия правило) *факты*))  

;; Проверка на подмножество
(defun подмножество (подмножество множество)
  (equal подмножество (intersection подмножество множество))) 

;; Добавление выводов
(defun добавь-выводы (правило)
  (do ((выводы (правило-выводы правило)
               (cdr выводы)))
      ((null выводы) *факты*)
      (if (OwnFooMember (car выводы) *факты*)
          nil
          (printsline (strCat "Согласно правилу " 
                  (output (правило-имя правило)) " "))) 
      (выведи-элементы (car выводы))
      (push (car выводы) *факты*)))

;; Вывод выбранного элемента
(defun выведи-элементы (список)     
      (mapcar (lambda (элемент) 
               (print элемент)  
               (prints " ")) список)
      (terpri) t)

;; Main
(defun Дарвин ()
  (очистка)
  (запрос-фактов)
  (PrintsLine (strCat "факты : " (output *факты*)))
  (знаток-зверей *гипотезы*))

;; Проверка гипотез
(defun знаток-зверей (гипотезы)
  (cond 
    ((null гипотезы) "Ничего доказать не могу")
    ((докажи (car гипотезы)) (car гипотезы))
    (t (знаток-зверей (cdr гипотезы)))))

;; Доказательство гипотез
(defun докажи (гипотеза)
  (defdyn *запросы*)
  ;; (defglob *запросы*)
  (let ((правила nil))
    (cond ((OwnFooMember гипотеза *факты*) t)
          ((setq правила (возможные гипотеза))
           (if (прямо гипотеза правила) t
               (рекурсивно гипотеза правила)))
          (t (cond 
               ((OwnFooMember гипотеза *запросы*) nil)
               ((and
               	  (print " Проверяю гипотезу ")
               	  (print гипотеза)
                  (prints " Это правда, что: ")
                  (выведи-элементы гипотеза)
                  (eq (read) 'Да))
                  (setq *факты* 
                       (union (list гипотеза)
                              *факты*)) t)
               (t (push гипотеза *запросы*) nil))))))                

;; Исключение неактульных гипотез
(defun возможные (гипотеза)
   (mapcan #'(lambda (x) (if (OwnFooMember гипотеза (правило-выводы x) )
                           (list x))) *правила*))					   

;; Проверка на наличие самого ответа в гипотезах
(defun прямо (гипотеза возможные)
   (cond ((null возможные) nil)
         ((null *факты*) nil)
         ((проверь-правило (car возможные)) (добавь-выводы (car возможные)))
         (t (прямо гипотеза (cdr возможные)))))	 

;; (СМ строку 192) --> остальные случаи
(defun рекурсивно (гипотеза возможные)
   (cond ((null возможные) nil)
         ((проверь-непрямо (правило-условия (car возможные)))
            (добавь-выводы (car возможные)))
         (t (рекурсивно гипотеза (cdr возможные)))))		 

(defun проверь-непрямо (условия)
    (every #'докажи условия))

(defun очистка () ;; } for debug
	(setq *факты* nil)
	(setq *запросы* nil))

;; Анализ фактов от пользователя
(defun ввод-фактов (strt)
	(let ((acc nil)
		 (res nil)
		 (inp (input (strCat "(" strt " и)"))))
		 (iter (for a in inp)
		 	(cond ((eq 'и a) (collecting acc into res)
		 		(setq acc nil))
		 		(t (collecting a into acc)))) res))

;; Получение фактов от пользователя
(defun запрос-фактов ()
	(setq *факты* (ввод-фактов (ask "Введите информацию о животном. Если такой информации нет, то введите [ОК]"))))

(setq *база-знаний* '(ПРАВИЛО1 ПРАВИЛО2 ПРАВИЛО3 ПРАВИЛО4 ПРАВИЛО5 ПРАВИЛО6 	
				      ПРАВИЛО7 ПРАВИЛО8 ПРАВИЛО9 ПРАВИЛО10 ПРАВИЛО11 ПРАВИЛО12
					  ПРАВИЛО13 ПРАВИЛО14))

;; Создание глобальных переменных (СМ строку 1-6)
(setq *правила* (анализируй *база-знаний*))

;; Подготовка к работе с пользователем
(PrintLine "Для запуска системы введите [(Дарвин)] ")